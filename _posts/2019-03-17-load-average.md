---
layout: post
title: 平均负载
categories: [Linux]
---

## 平均负载的定义

单位时间内， 系统处于**可运行状态**和**不可中断状态**的进程数。也可以理解成单位时间内，活跃的进程数。

可运行状态： 正在使用或者等待使用CPU的进程，使用top命令查看时，状态S为R的进程

不可中断状态： 正处在内核态关键流程中的进程。最常见的是等待硬件设备的IO响应。不可中断状态是**系统对进程和硬件设备的一种保护机制**。

例如， 当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，是不能被其他进程或者中断打断的，这时候的进程就处于不可中断状态，如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。

Stack Overflow上对不可中断状态进程的解释

```
An uniterruptable process is a process which happens to be in a system call(kernel function) that can't be interrupted by a signal.
```

也就是说，处于不可中断状态的进程，在执行系统调用之后会被阻塞，而且不能被中断(杀掉)，直到系统调用完成。这系统系统调用实际上都是瞬时完成的，通过`ps`命令一般看不到这些进程，如果`ps`命令能观察到，可能是IO出现了问题，因为程序之所以进入不可中断状态，就是因为得不到相关IO响应(磁盘IO、网络IO、其他外设IO)。所以要想进程退出不可中断状态，就得使进程等待的IO恢复。

## 查看平均负载

### 使用`uptime`命令查看

使用命令`man uptime`查看`uptime`的作用：

```
Gives  a  one  line display of the following information. The current time, how long the system has been running, how many users are currently logged on, and the system load averages for the past 1, 5, and 15 minutes.
```

即查看当前时间，系统已经运行的时间、当前登录的用户数以及过去1、5、15分钟系统的平均负载。

```shell
uptime
```


![](http://blog.linyimin.club/images/posts/uptime.png)


可以看到，过去1、5、15分钟，本系统的负载分别是1.05，1.27和1.31， 充分利用好这三个值，可以让我们更全面、更立体的理解目前系统的负载状态。

如果1、 5、 15分钟的平均负载：

- 基本相同，说明系统的负载很稳定；
- 如果1分钟前的负载远大于15分钟前的负载，说明最近1分钟的负载在增加。这种情况可能是临时性的，需要持续的观察。一旦1分钟的平均负载过大，说明系统发生了过载，需要想办法分析优化了；
- 如果1分钟前的负载远小于15钟前的负载，说明系统的负载在下降。

根据上图可以知道，整体来说系统的负载很稳定。那平均负载为多少时，才能保证系统的运行效率呢？

## 平均负载为多少时合理

最理想的情况下，平均负载和系统CPU的逻辑核数一致。所以我们需要先知道系统中CPU的逻辑核数。

通过读取/proc/cpuinfo文件获取系统CPU的信息。Linux系统贯彻“一切都是文件”的思想，所以系统相关的很多信息，进程状态都可以通过读取相关文件来获取。

Linux系统上的/proc文件目录是一种文件系统，及proc文件系统。与其他常见的文件系统不同，proc文件系统是一种伪文件系统（虚拟文件系统），所有的文件都存储在内存中，不占用任何的磁盘空间，存储的是当前内核运行状态的一系列文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息。可以理解为Linux为用户提供一种以文件系统的方式实现进程和内核的通信接口。

### 查看CPU信息

```shell
cat /proc/cpuinfo
```

![cpu information](http://blog.linyimin.club/images/posts/cpuinfo.png)

相关字段说明

- processor: 每个逻辑处理器的id
- physical id: 物理封装的处理器id
- CPU cores： 一个物理封装的处理器中内核的数量
- siblings: 一个物理封装的处理器中逻辑处理器的数量

CPU的逻辑核数 = physical id * siblings = processor的个数

也可以直接计算processor的个数

```shell
cat /proc/cpuinfo | grep 'processor' | wc -l
```

一般来说，当平均负载高于CPU数量的70%时，就应该分析排查负载高的问题了，因为负载过高，就有可能导致进程的响应过慢，从而影响服务的正常功能。

最推荐的方法是： 监控系统的平均负载，根据相关的历史数据，判断负载的变化趋势，当发现负载有明显的升高趋势时，再去做相关的分析和调查。

## 平均负载和CPU使用率

平均负载和CPU使用率并不存在并不是完全对应的，因为平均负载表示的是单位时间内，系统中处于**可运行状态**和**不可中断状态**下的进程数，而CPU使用率表示的是单位时间下CPU的繁忙程度。所以应该具体情况具体分析：

- 对于大量CPU密集型进程： 平均负载会升高， 同时会使用大量的CPU，所以CPU的使用率也会升高；
- 对于大量IO密集型进程： 平均负载会升高，但是大部分的进程都在等待IO响应，CPU处于空闲状态，CPU使用率可能不会升高； 
- 对于大量处于等待CPU的进程， 平均负载会升高，而由于进程的调度也会使用CPU，所以CPU使用率也会升高。

## 平均负载案例分析
