---
layout: post
title: CPU上下文切换
categories: [Linux]
---

> 破山中贼易，破心中贼难

Linux是一个多任务操作系统，它支持远大于逻辑CPU数量的任务同时运行。当然这些任务不是真的同时运行的，而是系统在很短的时间内，将CPU按照时间分片的方式轮流分配给这些任务，由于时间果断，用户无法感知任务的切换运行，造成多个任务同时运行的错觉。

要实现这种效果，必要要保证CPU知道在运行某个任务之前，清楚任务要从哪里加载，又从哪里开始运行。我们把这些信息成为**CPU上下文**。CPU在切换任务时，需要保存前一个任务的上下文，然后加新任务的上下文，最后开始运行新任务，我们成这个过程为**CPU上下文切换**。

根据任务的不同，我们将CPU上下文切换分为三种场景：**进程上下文切换**、**线程上下文切换**以及**中断上下文切换**。在具体介绍这三种上下文切换之前，先补充一些基础概念知识。

# 用户空间和内核空间

在CPU的所有指令中，有些指令是非常危险的，如果错用会导致操作系统的崩溃，比如清理内存、设置时钟等操作。为了提高操作系统的稳定性 ，只允许操作系统及其相关模块使用这些危险的CPU指令。比如Intel的CPU将指令的特权等级分为4个级别： Ring0~Ring3.

现代操作系统都采用虚拟存储进行存储管理。操作系统将虚拟存储空间分为两部分：内核空间和用户空间。内核空间供内核使用，而用户空间供普通用户进程使用。操作系统的核心是内核(kernel),独立于普通的应用程序，拥有访问受保护的内存空间及底层硬件设备的所有权限。

从以上的描述中，我们可以知道：

<font color="#dd0000">内核空间存放的是内核代码和数据，而用户空间存放的是用户程序的代码和数据。不管内核空间还是用户空间，它们都处于虚拟空间中。</font><br />

# 用户态和内核态

- 当一个任务(进程)执行**系统调用**陷入内核代码中执行时，称进程处于内核运行态(内核态)
  
  此时处理器处于特权最高(Ring0)的内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。

- 当进程在执行用户自己的代码时，则称其处于用户运行态(用户态)。此时处理器在特权级最低的(3级)用户代码中执行。当正在执行的用户程序被中断程序中断时，此时用户程序也可以象征性的称为处于进程的内核台态，因为中断处理程序将使用当前进程的内核栈。

注意：在某些实现中，中断服务程序不在进程的上下文中执行，它们在一个与所有进程都无关的、专门的中断上下文中执行。之所以存在一个专门的执行环境，就是为了保证中断服务程序能够在第一时间响应和处理中断请求，然后快速地退出。



